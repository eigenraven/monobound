/**
 * Utilities for working with Mono's C API.
 * 
 * License:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * Permission is hereby granted,free of charge,to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use,reproduce,display,distribute,
 * execute,and transmit the Software,and to prepare derivative works of the
 * Software,and to permit third-parties to whom the Software is furnished to
 * do so,all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement,including
 * the above license grant,this restriction and the following disclaimer,
 * must be included in all copies of the Software,in whole or in part,and
 * all derivative works of the Software,unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR
 * IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE,TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY,WHETHER IN CONTRACT,TORT OR OTHERWISE,
 * ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
module monobound.utils;

public import derelict.mono.types;
import derelict.mono.mono;
public import monobound.attributes;
public import std.string;
import core.stdc.string;
import std.array, std.meta, std.traits, std.utf;
import monobound.runtime : Mono;

/// Converts a Mono C string to a D string and frees the Mono object.
string monoOwnedCStrToD(const(char)* str) nothrow @trusted
{
	if (str is null)
		return "";
	string S = str[0 .. strlen(str)].idup;
	mono_free(cast(void*) str);
	return S;
}

immutable(wchar)* toWstringz(wstring str) nothrow @safe
{
	if (str.length == 0)
		return &"\0"w[0];
	if (str[$ - 1] != '\0')
		str ~= '\0';
	return &str[0];
}

wstring fromWstringz(const(wchar)* str) nothrow @trusted
{
	size_t len;
	for (; str[len] != '\0'; len++)
		len++;
	return cast(immutable) str[0 .. len];
}

/// The bool as it appears in function argument lists
alias monoBoolF = short;
/// The bool as it appears in structure definitions
alias monoBoolM = int;

/// Wrapper around a Mono pointer, frees it in the destructor.
struct MonoPtr(T)
{
	@disable this(this);
	T* ptr;
	alias ptr this;
	~this()
	{
		mono_free(cast(void*) ptr);
	}
}

enum BoundTypeContext
{
	FunctionList,
	Member
}

private alias PrimitiveTypes = AliasSeq!(void, char, wchar, dchar, byte, short,
		int, long, ubyte, ushort, uint, ulong, float, double);

/// Either the identifier of T, or, if it has one, the renamed variant as done by the @MonoBind UDA.
template RenamedIdOf(alias T)
{
	private enum string xid = __traits(identifier, T);
	private alias udas = getUDAs!(T, MonoBind);
	static if (udas.length > 0 && __traits(compiles, () {
			string a = udas[0].rename;
		}))
	{
		private enum string rid = udas[0].rename;
		enum string RenamedIdOf = rid.length ? rid : xid;
	}
	else
	{
		enum string RenamedIdOf = xid;
	}
}

/// Type information for T regarding D<-->Mono runtime interactions.
template MonoboundTypeInfo(T, BoundTypeContext Tctx, bool alreadyReffed = false)
{
	/// If true, this type doesn't require special marshalling code to pass between the runtimes.
	enum bool isPrimitive = (staticIndexOf!(T, PrimitiveTypes) > -1);
	/// The corresponding C#/other .NET language type name.
	enum string csTypeName = csTypeName_impl();
	/// The D type name that corresponds to the native (C api) type as used by the runtime to represent objects of this kind.
	enum string drtTypeName = drtTypeName_impl();
	/// The D type corresponding to drtTypeName
	mixin("alias DrtType = " ~ drtTypeName ~ ";");

	static if (!is(T == void))
	{

		/// Unboxes the value from the Mono representation.
		T unwrapToD()(DrtType wrapped)
		{
			static if (isPrimitive)
				return cast(T)(wrapped);
			else static if (is(T == bool))
				return (wrapped != 0);
			else static if (is(T == enum))
				return cast(T)(wrapped);
			else static if (isSomeString!T)
			{
				const(wchar)[] slice = mono_string_chars(wrapped)[0 .. mono_string_length(wrapped)];
				static if (is(T == immutable(char)[]) || is(T == const(char)[]) || is(T == char[]))
					return cast(T)(slice.byUTF!char.array);
				else static if (is(T == immutable(wchar)[])
						|| is(T == const(wchar)[]) || is(T == wchar[]))
					return cast(T)(slice.byUTF!wchar.array);
				else static if (is(T == immutable(dchar)[])
						|| is(T == const(dchar)[]) || is(T == dchar[]))
					return cast(T)(slice.byUTF!dchar.array);
				else
					static assert(0, "Unsupported string type to unwrap from Mono.");
			}
			else
				static assert(0, "Unsupported type to unwrap from Mono.");
		}

		/// Boxes the value for the Mono runtime.
		DrtType wrapForMono()(T rawValue)
		{
			static if (isPrimitive)
				return cast(DrtType)(rawValue);
			else static if (is(T == bool))
			{
				final switch (Tctx) with (BoundTypeContext)
				{
				case FunctionList:
					return rawValue ? monoBoolF(-1) : monoBoolF(0);
				case Member:
					return rawValue ? monoBoolM(1) : monoBoolF(0);
				}
			}
			else static if (is(T == enum))
				return cast(DrtType) rawValue;
			else static if (isSomeString!T)
			{
				static if (is(T == immutable(char)[]) || is(T == const(char)[]) || is(T == char[]))
					return mono_string_new_len(Mono.getDomain,
							cast(const(char)*) T.ptr, cast(uint) T.length);
				else static if (is(T == immutable(wchar)[])
						|| is(T == const(wchar)[]) || is(T == wchar[]))
					return mono_string_new_utf16(Mono.getDomain,
							cast(const(mono_unichar2)*) T.ptr, cast(uint) T.length);
				else static if (is(T == immutable(dchar)[])
						|| is(T == const(dchar)[]) || is(T == dchar[]))
					return mono_string_new_utf32(Mono.getDomain,
							cast(const(mono_unichar4)*) T.ptr, cast(uint) T.length);
				else
					static assert(0, "Unsupported string type to wrap for Mono.");
			}
			else
				static assert(0, "Unsupported type to wrap for Mono.");
		}

		/// Manages the GC interactions/reference count - call when object enters a native context.
		void beginUse(DrtType rawValue)
		{
			//
		}

		/// Call at the end of the scope where beginUse was called.
		void endUse(DrtType rawValue)
		{
			//
		}

	}

	private string csTypeName_impl()
	{
		static if (is(T == bool))
		{
			final switch (Tctx) with (BoundTypeContext)
			{
			case FunctionList:
				return "bool";
			case Member:
				return "byte";
			}
		}
		else static if (is(T == void))
		{
			return "void";
		}
		else static if (is(T == enum))
		{
			return "int";
		}
		else static if (isIntegral!T)
		{
			static if (is(T == char))
				return "byte";
			else static if (is(T == wchar))
				return "char";
			else static if (is(T == dchar))
				return "uint";
			else static if (is(T == ubyte))
				return "byte";
			else static if (is(T == byte))
				return "sbyte";
			else static if (is(T == ushort))
				return "ushort";
			else static if (is(T == short))
				return "short";
			else static if (is(T == uint))
				return "uint";
			else static if (is(T == int))
				return "int";
			else static if (is(T == ulong))
				return "ulong";
			else static if (is(T == long))
				return "long";
			else
				static assert(0, "Unsupported integral type " ~ T.stringof);
		}
		else static if (isFloatingPoint!T)
		{
			static if (is(T == float))
				return "float";
			else static if (is(T == double))
				return "double";
			else
				static assert(0, "Unsupported floating point type " ~ T.stringof);
		}
		else static if (isSomeString!T)
		{
			return "string";
		}
		else static if (is(T : U[], U))
		{
			return MonoboundTypeInfo!(U, Tctx, true) ~ "[]";
		}
		else static if (is(T : U*, U))
		{
			return (alreadyReffed ? "" : "ref ") ~ monoTypeOf!(U, Tctx, true);
		}
		else static if (is(T == class))
		{
			return RenamedIdOf!T;
		}
		else static if (is(T == struct))
		{
			return RenamedIdOf!T;
		}
		else
		{
			static assert(0, "Unsupported type " ~ T.stringof);
		}
	}

	private string drtTypeName_impl()
	{
		static if (is(T == bool))
		{
			final switch (tc) with (TypeContext)
			{
			case FunctionList:
				return "monoBoolF";
			case Member:
				return "monoBoolM";
			}
		}
		else static if (is(T == void))
		{
			return "void";
		}
		else static if (is(T == enum))
		{
			return "int";
		}
		else static if (isIntegral!T)
		{
			static if (is(T == char))
				return "byte";
			else static if (is(T == wchar))
				return "char";
			else static if (is(T == dchar))
				return "uint";
			else static if (is(T == ubyte))
				return "ubyte";
			else static if (is(T == byte))
				return "byte";
			else static if (is(T == ushort))
				return "ushort";
			else static if (is(T == short))
				return "short";
			else static if (is(T == uint))
				return "uint";
			else static if (is(T == int))
				return "int";
			else static if (is(T == ulong))
				return "ulong";
			else static if (is(T == long))
				return "long";
			else
				static assert(0, "Unsupported integral type " ~ T.stringof);
		}
		else static if (isFloatingPoint!T)
		{
			static if (is(T == float))
				return "float";
			else static if (is(T == double))
				return "double";
			else
				static assert(0, "Unsupported floating point type " ~ T.stringof);
		}
		else static if (isSomeString!T)
		{
			return "MonoString*";
		}
		else static if (is(T : U[], U))
		{
			return "MonoArray*";
		}
		else static if (is(T : U*, U))
		{
			return "MonoObject*";
		}
		else static if (is(T == class))
		{
			return "MonoObject*";
		}
		else static if (is(T == struct))
		{
			return "MonoObject*";
		}
		else
		{
			static assert(0, "Unsupported type " ~ T.stringof);
		}
	}
}
